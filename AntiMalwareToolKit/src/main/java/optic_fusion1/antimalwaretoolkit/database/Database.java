/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalwaretoolkit.database;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.stream.Collectors;
import static optic_fusion1.antimalwaretoolkit.Main.LOGGER;
import optic_fusion1.antimalwaretoolkit.configuration.file.FileConfiguration;

public class Database {

  public static final String DATABASE_URL = "https://raw.githubusercontent.com/OpticFusion1/MCAntiMalwareDatabase/master/database.db";
  private Connection connection;

  public Database() {
    try {
      File tempFile = File.createTempFile("AntiMalwareToolKit", "db");
      try {
        Files.copy(new URL(DATABASE_URL).openStream(), tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
      } catch (IOException e) {
        e.printStackTrace();
      }
      connection = DriverManager.getConnection("jdbc:sqlite:" + tempFile.toURI());
    } catch (SQLException | IOException e) {
      e.printStackTrace();
    }
  }

  public final String isChecksumWhitelisted = "SELECT count(*) FROM WhitelistedChecksums WHERE Checksum = ?";

  public boolean isChecksumWhitelisted(String checksum) {
    try {
      PreparedStatement pSt = connection.prepareStatement("SELECT count(*) FROM WhitelistedChecksums WHERE Checksum = ?");
      pSt.setString(1, checksum);
      try ( ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          if (rs.getInt("count(*)") > 0) {
            return true;
          }
        }
      }
    } catch (SQLException ex) {
      ex.printStackTrace();
    }
    return false;
  }

  public void insertWhitelist(Connection connection, String key, FileConfiguration config) throws SQLException {
    if (config.isConfigurationSection(key)) {
      config.getConfigurationSection(key).getKeys(false).forEach((subKey) -> {
        List list = config.getList(key + "." + subKey);
        if (list == null) {
          System.out.println("ERROR: " + key + "." + subKey);
          return;
        }
        if (list.size() > 0 && list.get(0) instanceof List) {
          list = (List) ((List<List>) list).stream().flatMap(List::stream).collect(Collectors.toList());
        }
        try {
          insertWhitelistEntries(connection, key, subKey, list);
        } catch (SQLException e) {
          e.printStackTrace();
        }
      });
    } else {
      List list = (List<List<String>>) config.getList(key);
      if (list.size() > 0 && list.get(0) instanceof List) {
        list = (List) ((List<List>) list).stream().flatMap(List::stream).collect(Collectors.toList());
      }
      insertWhitelistEntries(connection, key, key, list);
    }
  }

  final String insertWhitelistPlugin = "INSERT OR IGNORE INTO WhitelistedPlugins ('Name', 'Author') VALUES (?, ?);";
  final String getWhitelistPluginID = "SELECT _rowid_ FROM WhitelistedPlugins WHERE Name = ? AND Author = ?;";
  final String insertWhitelistChecksum = "INSERT OR IGNORE INTO WhitelistedChecksums ('Checksum','WhitelistedPlugin') VALUES (?, ?);";

  public void insertWhitelistEntries(Connection connection, String author, String pluginName, List<String> checksums)
          throws SQLException {
    PreparedStatement pSt = connection.prepareStatement(insertWhitelistPlugin);
    pSt.setString(1, pluginName);
    pSt.setString(2, author);
    pSt.executeUpdate();

    int pluginID = getWhitelistPluginID(connection, author, pluginName);

    pSt = connection.prepareStatement(insertWhitelistChecksum);
    for (String checksum : checksums) {
      pSt.setString(1, checksum);
      pSt.setInt(2, pluginID);
      pSt.executeUpdate();
      System.out.println("[Whitelist] inserting Author: " + author + " Plugin Name: " + pluginName + " Checksum: " + checksum);
    }
  }

  public int getWhitelistPluginID(Connection connection, String author, String pluginName) throws SQLException {
    PreparedStatement pSt = connection.prepareStatement(getWhitelistPluginID);
    pSt.setString(1, pluginName);
    pSt.setString(2, author);
    ResultSet rs = pSt.executeQuery();
    if (rs.next()) {
      return rs.getInt("rowid");
    }
    return -1;
  }

  public void createWhitelistTables(Connection connection) throws SQLException {
    connection.prepareStatement(
            "CREATE TABLE IF NOT EXISTS \"WhitelistedPlugins\" (\n" + "	\"Name\"	TEXT NOT NULL,\n"
            + "	\"Author\"	TEXT NOT NULL,\n" + "	\"ResourceID\"	TEXT, UNIQUE(Name, Author)\n" + ")")
            .execute();

    connection.prepareStatement("CREATE TABLE IF NOT EXISTS \"WhitelistedChecksums\" (\n"
            + "	\"Checksum\"	TEXT NOT NULL UNIQUE,\n" + "	\"WhitelistedPlugin\"	INTEGER NOT NULL\n" + ")")
            .execute();
  }

  public boolean isChecksumBlacklisted(String checksum) {
    System.out.println("Checksum: " + checksum);
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedChecksums WHERE Checksum = ?", checksum);
  }

  private boolean queryResultGreaterThanZero(String query, String a) {
    try {
      PreparedStatement pSt = connection.prepareStatement(query);
      pSt.setString(1, a);
      try ( ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          if (rs.getInt("count(*)") > 0) {
            return true;
          }
        }
      }
    } catch (SQLException ex) {
      LOGGER.exception(ex);
    }
    return false;
  }

  public Connection getConnection() {
    return connection;
  }

}
