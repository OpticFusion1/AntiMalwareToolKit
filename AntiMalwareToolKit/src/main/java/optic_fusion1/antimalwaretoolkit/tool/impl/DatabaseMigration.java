/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package optic_fusion1.antimalwaretoolkit.tool.impl;

import java.io.File;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import static optic_fusion1.antimalwaretoolkit.Main.DATABASE;
import static optic_fusion1.antimalwaretoolkit.Main.LOGGER;
import optic_fusion1.antimalwaretoolkit.configuration.ConfigurationSection;
import optic_fusion1.antimalwaretoolkit.configuration.file.FileConfiguration;
import optic_fusion1.antimalwaretoolkit.configuration.file.YamlConfiguration;
import optic_fusion1.antimalwaretoolkit.tool.Tool;
import org.jetbrains.annotations.Nullable;

public class DatabaseMigration extends Tool {

  @Override
  public void run(List<String> args) {
    try {
      createMalwareCheckTables(DATABASE.getConnection());
      
      File databaseFile = new File(args.get(3));
      FileConfiguration databaseConfig = YamlConfiguration.loadConfiguration(databaseFile);
      databaseConfig.getKeys(false).forEach((key) -> {
        try {
          insertMalwareChecks(DATABASE.getConnection(), key, databaseConfig.getConfigurationSection(key));
        } catch (SQLException e) {
          e.printStackTrace();
        }
      });
      
      createMaliciousDevBansTables(DATABASE.getConnection());
      File bansFile = new File(args.get(1));
      FileConfiguration bansConfig = YamlConfiguration.loadConfiguration(bansFile);
      bansConfig.getKeys(false).forEach((key) -> {
        try {
          insertBans(DATABASE.getConnection(), key, bansConfig.getConfigurationSection(key));
        } catch (SQLException e) {
          e.printStackTrace();
        }
      });
      
      DATABASE.createWhitelistTables(DATABASE.getConnection());
      
      File whitelistFile = new File(args.get(2));
      FileConfiguration whitelist = YamlConfiguration.loadConfiguration(whitelistFile);
      whitelist.getKeys(false).forEach((key) -> {
        try {
          DATABASE.insertWhitelist(DATABASE.getConnection(), key, whitelist);
        } catch (SQLException e) {
          e.printStackTrace();
        }
      });
    } catch (SQLException ex) {
      Logger.getLogger(DatabaseMigration.class.getName()).log(Level.SEVERE, null, ex);
    }
  }

  public String getDescription() {
    return "Usage: databasemigration {database.yml} {banned-players.yml} {checksums.yml} {database.db}";
  }

  final String insertMaliciousDev = "INSERT OR IGNORE INTO BannedAuthors ('Name') VALUES (?);";
  final String insertPreviousName = "INSERT OR IGNORE INTO BannedAuthorsNames ('Name', 'AuthorID') VALUES (?, ?);";
  final String insertUUID = "INSERT OR IGNORE INTO BannedAuthorsUUIDs ('UUID', 'AuthorID') VALUES (?, ?);";

  private void insertBans(Connection connection, String key, @Nullable ConfigurationSection configurationSection)
          throws SQLException {
    PreparedStatement pSt = connection.prepareStatement(insertMaliciousDev);
    pSt.setString(1, key);
    pSt.executeUpdate();

    int authorID = getMaliciousDevID(connection, key);

    if (configurationSection.contains("previous-names")) {
      pSt = connection.prepareStatement(insertPreviousName);
      if (configurationSection.isList("previous-names")) {
        for (String previousName : configurationSection.getStringList("previous-names")) {
          pSt.setString(1, previousName);
          pSt.setInt(2, authorID);
          pSt.executeUpdate();
          LOGGER.info("[Ban] Inserting Key: " + key + " Author ID: " + authorID + " Previous Name: " + previousName);
        }
        pSt.close();
      } else {
        pSt.setString(1, configurationSection.getString("previous-names"));
        pSt.setInt(2, authorID);
        pSt.executeUpdate();
        pSt.close();
        LOGGER.info("[Ban] Inserting Key: " + key + " Author ID: " + authorID);
      }
    }

    if (configurationSection.contains("uuid")) {
      pSt = connection.prepareStatement(insertUUID);
      if (configurationSection.isList("uuid")) {
        for (String uuid : configurationSection.getStringList("uuid")) {
          pSt.setString(1, uuid);
          pSt.setInt(2, authorID);
          pSt.executeUpdate();
          LOGGER.info("[Ban] Inserting Key: " + key + " Author ID: " + authorID + " UUID: " + uuid);
        }
        pSt.close();
      } else {
        pSt.setString(1, configurationSection.getString("uuid"));
        pSt.setInt(2, authorID);
        pSt.executeUpdate();
        LOGGER.info("[Ban] Inserting Key: " + key + " Author ID: " + configurationSection.getString("uuid"));
      }
      pSt.close();
    }
  }

  private int getMaliciousDevID(Connection connection, String name) throws SQLException {
    PreparedStatement pSt = connection.prepareStatement("SELECT _rowid_ FROM BannedAuthors WHERE Name = ?");
    pSt.setString(1, name);
    ResultSet rs = pSt.executeQuery();
    if (rs.next()) {
      return rs.getInt("rowid");
    }
    return -1;
  }

  private void createMaliciousDevBansTables(Connection connection) throws SQLException {
    connection.prepareStatement(
            "CREATE TABLE IF NOT EXISTS \"BannedAuthors\" (\n" + "	\"Name\"	TEXT NOT NULL UNIQUE\n" + ")")
            .execute();

    connection.prepareStatement(
            "CREATE TABLE IF NOT EXISTS \"BannedAuthorsNames\" (\n" + "	\"Name\"	TEXT NOT NULL,\n"
            + "	\"AuthorID\"	INTEGER NOT NULL, UNIQUE(Name, AuthorID)\n" + ")")
            .execute();

    connection.prepareStatement(
            "CREATE TABLE IF NOT EXISTS \"BannedAuthorsUUIDs\" (\n" + "	\"UUID\"	TEXT NOT NULL,\n"
            + "	\"AuthorID\"	INTEGER NOT NULL, UNIQUE(UUID, AuthorID)\n" + ")")
            .execute();
  }

  final String insertMalwareCheckName = "INSERT OR IGNORE INTO MalwareChecks ('family', 'firstFoundDate') VALUES (?, date());";
  final String insertBlacklistedAuthor = "INSERT OR IGNORE INTO BlacklistedAuthors ('Name', 'MalwareID') VALUES (?, ?);";
  final String insertBlacklistedChecksum = "INSERT OR IGNORE INTO BlacklistedChecksums ('Checksum', 'MalwareID') VALUES (?, ?);";
  final String insertBlacklistedClasspath = "INSERT OR IGNORE INTO BlacklistedClasspaths ('Classpath', 'MalwareID') VALUES (?, ?);";
  final String insertBlacklistedStrings = "INSERT OR IGNORE INTO BlacklistedStrings ('String', 'MalwareID') VALUES (?, ?);";

  private void insertMalwareChecks(Connection connection, String key,
          @Nullable ConfigurationSection configurationSection) throws SQLException {
    if (configurationSection == null) {
      return;
    }
    PreparedStatement pSt = connection.prepareStatement(insertMalwareCheckName);
    pSt.setString(1, key);
    pSt.executeUpdate();

    int malwareID = getMalwareCheckRowID(connection, key);

    if (configurationSection.contains("blacklisted-authors")) {
      for (String author : configurationSection.getStringList("blacklisted-authors")) {
        pSt = connection.prepareStatement(insertBlacklistedAuthor);
        pSt.setString(1, author);
        pSt.setInt(2, malwareID);
        pSt.executeUpdate();
        LOGGER.info("[Malware Checks] Key: " + key + " Author: " + author + " Malware ID: " + malwareID);
      }
    }

    if (configurationSection.contains("blacklisted-checksums")) {
      for (String checksum : configurationSection.getStringList("blacklisted-checksums")) {
        pSt = connection.prepareStatement(insertBlacklistedChecksum);
        pSt.setString(1, checksum);
        pSt.setInt(2, malwareID);
        pSt.executeUpdate();
        LOGGER.info("[Malware Checks] Key: " + key + " Malware ID: " + malwareID + " Checksum: " + checksum);
      }
    }

    if (configurationSection.contains("blacklisted-classpaths")) {
      for (String classpath : configurationSection.getStringList("blacklisted-classpaths")) {
        pSt = connection.prepareStatement(insertBlacklistedClasspath);
        pSt.setString(1, classpath);
        pSt.setInt(2, malwareID);
        pSt.executeUpdate();
        LOGGER.info("[Malware Checks] Key: " + key + " Malware ID: " + malwareID + " Classpath: " + classpath);
      }
    }

    if (configurationSection.contains("blacklisted-strings")) {
      for (String string : configurationSection.getStringList("blacklisted-strings")) {
        pSt = connection.prepareStatement(insertBlacklistedStrings);
        pSt.setString(1, string);
        pSt.setInt(2, malwareID);
        pSt.executeUpdate();
        LOGGER.info("[Malware Checks] Key: " + key + " Malware ID: " + malwareID + " String: " + string);
      }
    }
  }

  private int getMalwareCheckRowID(Connection connection, String name) throws SQLException {
    PreparedStatement pSt = connection
            .prepareStatement("SELECT _rowid_ FROM MalwareChecks WHERE platform = \"Java\" AND family = ?");
    pSt.setString(1, name);
    ResultSet rs = pSt.executeQuery();
    if (rs.next()) {
      return rs.getInt("rowid");
    }
    return -1;
  }

  private void createMalwareCheckTables(Connection connection) throws SQLException {
    connection.prepareStatement(
            "CREATE TABLE IF NOT EXISTS \"MalwareChecks\" (\n" + "	\"type\"	TEXT NOT NULL DEFAULT 'MALWARE',\n"
            + "	\"platform\"	TEXT NOT NULL DEFAULT 'Java',\n" + "	\"family\"	TEXT NOT NULL UNIQUE,\n"
            + "	\"variant\"	TEXT NOT NULL DEFAULT 'A',\n" + "	\"firstFoundDate\"	TEXT NOT NULL,\n"
            + "	\"otherInfo\"	TEXT,\n" + "	PRIMARY KEY(\"family\")\n" + ")")
            .execute();

    connection
            .prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedStrings\" (\n"
                    + "	\"String\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
            .execute();

    connection
            .prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedClasspaths\" (\n"
                    + "	\"Classpath\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
            .execute();

    connection
            .prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedChecksums\" (\n"
                    + "	\"Checksum\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
            .execute();

    connection
            .prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedAuthors\" (\n"
                    + "	\"Name\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
            .execute();
  }

}
