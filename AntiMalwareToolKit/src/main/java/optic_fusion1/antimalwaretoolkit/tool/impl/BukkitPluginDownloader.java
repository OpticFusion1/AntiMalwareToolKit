/*
 * Copyright (C) 2021 Optic_Fusion1
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package optic_fusion1.antimalwaretoolkit.tool.impl;

import com.gargoylesoftware.htmlunit.BrowserVersion;
import com.gargoylesoftware.htmlunit.WebClient;
import com.gargoylesoftware.htmlunit.html.HtmlPage;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonNull;
import com.google.gson.JsonParser;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.StreamSupport;
import static optic_fusion1.antimalwaretoolkit.Main.LOGGER;
import optic_fusion1.antimalwaretoolkit.tool.Tool;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

/**
 * @author Maxililian Dorn (github.com/cerus)
 */
public class BukkitPluginDownloader extends Tool {

    @Override
    public void run(final List<String> args) {
        if (!args.isEmpty() && args.get(0).equalsIgnoreCase("help")) {
            LOGGER.info("Available options:");
            LOGGER.info("   from NUMBER      Sets the starting page (default 1)");
            LOGGER.info("   to NUMBER        Sets the end page (default -1 (= last available page))");
            LOGGER.info("   sort NUMBER      Sets the sorting mode (default 2)");
            LOGGER.info("                       1: Date created");
            LOGGER.info("                       2: Last updated");
            LOGGER.info("                       3: Name");
            LOGGER.info("                       4: Popularity");
            LOGGER.info("                       5: Total downloads");
            LOGGER.info("   dir PATH         Sets the download folder (default data/plugins/bukkit)");
            LOGGER.info("   threads NUMBER   Sets the amount of threads to use (default 4)");
            LOGGER.info("   multidir BOOL    Sets whether or not each project should be downloaded in a separate directory (default true)");
            return;
        }

        // Parse options
        final Options options = Options.parse(args);
        if (options.threads <= 0) {
            LOGGER.warn("At least one thread is needed");
            return;
        }

        LOGGER.info("Running Bukkit downloader with " + options.threads + " threads");

        // Create thread pool and web clients
        // Each thread has its own web client
        final Map<Long, WebClient> webClientMap = new HashMap<>();
        final ExecutorService threadPool = Executors.newFixedThreadPool(options.threads, runnable -> {
            final Thread thread = new Thread(runnable);

            final WebClient webClient = this.constructWebClient();
            webClientMap.put(thread.getId(), webClient);

            return thread;
        });
        threadPool.submit(() -> LOGGER.info("Thread pool is ready"));

        final int maxPage = options.toPage == -1 ? this.establishPages(webClientMap.values().iterator().next()) : options.toPage;
        if (maxPage <= options.fromPage) {
            LOGGER.warn("Invalid end page");
            return;
        }

        // Create download dir
        new File(options.downloadFolder).mkdirs();

        final AtomicBoolean isDone = new AtomicBoolean(false);
        for (int i = options.fromPage; i <= maxPage; i++) {
            final int pageNumber = i;
            // Submit page download
            threadPool.submit(() -> {
                try {
                    this.downloadPage(webClientMap.get(Thread.currentThread().getId()), options, pageNumber);
                } catch (final IOException e) {
                    LOGGER.error("Failed to download page", e);
                }

                if (pageNumber == maxPage) {
                    // Last page was downloaded, we are done
                    isDone.set(true);
                }
            });
        }

        // Block while the downloader does its thing
        while (!isDone.get()) {
        }

        // Clean up
        LOGGER.info("Cleaning up...");
        webClientMap.forEach((threadId, webClient) -> {
            LOGGER.info("Disposing web client for thread #" + threadId);
            webClient.close();
        });
        webClientMap.clear();
    }

    /**
     * Creates a new webclient
     *
     * @return a brand new web client
     */
    private WebClient constructWebClient() {
        // Construct web client
        final WebClient webClient = new WebClient(BrowserVersion.FIREFOX);
        webClient.getOptions().setJavaScriptEnabled(true);
        webClient.setJavaScriptTimeout(10000);
        webClient.getOptions().setTimeout(15000);
        webClient.getOptions().setCssEnabled(false);
        webClient.getOptions().setRedirectEnabled(true);
        webClient.getOptions().setThrowExceptionOnFailingStatusCode(false);
        webClient.getOptions().setThrowExceptionOnScriptError(false);
        webClient.getOptions().setPrintContentOnFailingStatusCode(false);
        webClient.getOptions().setUseInsecureSSL(true);
        webClient.getOptions().setPopupBlockerEnabled(false);
        Logger.getLogger("com.gargoylesoftware").setLevel(Level.OFF);
        return webClient;
    }

    /**
     * Retrieves the amount of pages
     *
     * @param webClient The web client
     *
     * @return The amount of pages
     */
    private int establishPages(final WebClient webClient) {
        try {
            // Fetch page
            final HtmlPage page = webClient.getPage("https://dev.bukkit.org/bukkit-plugins");

            // Parse document and select navigators
            final Elements elements = Jsoup.parse(page.asXml())
                    .body()
                    .select("ul[class=\"b-pagination-list paging-list j-tablesorter-pager j-listing-pagination\"]");

            // Retrieve first navigator
            final Element element = elements.get(0);

            // Retrieve last element of navigator and parse it's link attribute
            final Element child = element.children().last()
                    .children().last();
            return Integer.parseInt(child.attr("href").split("=")[1]);
        } catch (final IOException e) {
            e.printStackTrace();
        }
        return 0;
    }

    /**
     * Scrapes a bukkit page and downloads the individual resources
     *
     * @param webClient The web client
     * @param options   The parsed options
     * @param pageNo    The page
     *
     * @throws IOException if the page cannot be loaded
     */
    private void downloadPage(final WebClient webClient, final Options options, final int pageNo) throws IOException {
        LOGGER.info("Downloading page " + pageNo);

        // Fetch page, parse project list
        final HtmlPage page = webClient.getPage("https://dev.bukkit.org/bukkit-plugins?filter-sort=" + options.sort + "&page=" + pageNo);
        final Elements elements = Jsoup.parse(page.asXml())
                .body()
                .select("ul[class=\"listing listing-project project-listing\"]");
        final Element projectList = elements.first();

        // Loop through project list and parse resource
        for (final Element element : projectList.children()) {
            final String url = element.children().first()
                    .children().first()
                    .attr("href");
            final Element detailsElement = element.children().last();
            final Element nameInfoElement = detailsElement.children().first();
            final String resourceName = nameInfoElement.children().first()
                    .children().first()
                    .text();
            final String resourceAuthor = nameInfoElement.children().last()
                    .children().last()
                    .text();

            // Connect to the resource page and retrieve the id
            final HtmlPage projectPage = webClient.getPage(url);
            final String projectId = Jsoup.parse(projectPage.asXml())
                    .body()
                    .select("div[class=\"info-data\"]")
                    .first()
                    .text();

            // Download resource
            final ResourceInfo resourceInfo = new ResourceInfo(projectId, resourceName, resourceAuthor);
            try {
                this.downloadResource(options, resourceInfo);
            } catch (final IOException e) {
                e.printStackTrace();
                LOGGER.error("Failed to download resource", e);
            }
        }
    }

    /**
     * Downloads a resource
     *
     * @param options      The parsed options
     * @param resourceInfo The resource to download
     *
     * @throws IOException if the resource cannot be downloaded
     */
    private void downloadResource(final Options options, final ResourceInfo resourceInfo) throws IOException {
        LOGGER.info("Downloading '" + resourceInfo.name + "' by " + resourceInfo.author + " (ID " + resourceInfo.id + ")");

        // Make api request and retrieve releases
        final HttpURLConnection connection = (HttpURLConnection) new URL("https://servermods.forgesvc.net/servermods/files?projectIds="
                + resourceInfo.id).openConnection();
        connection.setDoInput(true);
        final InputStream inputStream = connection.getInputStream();

        // Collect response
        final StringBuilder stringBuilder = new StringBuilder();
        String s;
        try (final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
            while ((s = reader.readLine()) != null) {
                stringBuilder.append(s);
            }
        }

        // Parse response
        final JsonArray verArray = JsonParser.parseString(stringBuilder.toString()).getAsJsonArray();
        StreamSupport.stream(verArray.spliterator(), true)
                .map(JsonElement::getAsJsonObject)
                .filter(jsonObject -> !(jsonObject.get("downloadUrl") instanceof JsonNull)) // Sometimes the download links are null (wtf)
                .forEach(jsonObject -> {
                    final String downloadUrl = jsonObject.get("downloadUrl").getAsString();
                    final String fileName = jsonObject.get("fileName").getAsString();

                    LOGGER.info("Downloading release '" + fileName + "' from resource '" + resourceInfo.name + "'");
                    this.downloadRelease(resourceInfo.id, downloadUrl, fileName, options);
                });
    }

    /**
     * Downloads a single release of a resource
     *
     * @param projectId   The project id
     * @param downloadUrl The download url
     * @param fileName    The name of the file
     * @param options     The parsed options
     */
    private void downloadRelease(final String projectId, final String downloadUrl, final String fileName, final Options options) {
        final File downloadFolder = options.perProjectDirs
                ? new File(options.downloadFolder, projectId)
                : new File(options.downloadFolder);
        downloadFolder.mkdirs();

        File destination = new File(downloadFolder, fileName);
        if (destination.exists()) {
            // Extract name
            final String namePartOne = fileName.substring(0, fileName.lastIndexOf("."));
            final String namePartTwo = fileName.substring(fileName.lastIndexOf("."));
            int c = 0;

            // Build new name
            while (destination.exists()) {
                destination = new File(downloadFolder, namePartOne + "_" + (c++) + namePartTwo);
            }
        }

        // Download file
        try {
            final HttpURLConnection connection = (HttpURLConnection) new URL(downloadUrl).openConnection();
            connection.setDoInput(true);
            final InputStream inputStream = connection.getInputStream();
            Files.copy(inputStream, destination.toPath());
        } catch (final IOException e) {
            LOGGER.error("Failed to download release", e);
        }
    }

    private static class ResourceInfo {

        public String id;
        public String name;
        public String author;

        public ResourceInfo(final String id, final String name, final String author) {
            this.id = id;
            this.name = name;
            this.author = author;
        }

    }

    private static class Options {

        /**
         * Starting page
         */
        public int fromPage = 1;

        /**
         * End page
         * -1 = Last available page
         */
        public int toPage = -1;

        /**
         * Sorting mode
         * 1 = Date created
         * 2 = Last updated
         * 3 = Name
         * 4 = Popularity
         * 5 = Total downloads
         */
        public int sort = 2;

        /**
         * Downloads folder
         */
        public String downloadFolder = "./data/plugins/bukkit";

        /**
         * Amount of threads
         */
        public int threads = 4;

        /**
         * whether or not each project should be downloaded in a separate directory
         */
        public boolean perProjectDirs = true;

        /**
         * Attempts to parse the arguments
         *
         * @param args The arguments
         *
         * @return Parsed options
         */
        public static Options parse(final List<String> args) {
            final Options options = new Options();

            if (!args.isEmpty()) {
                // Parse args
                for (int i = 0; i < args.size() - 1; i++) {
                    final String arg = args.get(i).toLowerCase();

                    switch (arg) {
                        // Starting page
                        case "from" -> options.fromPage = Integer.parseInt(args.get(i + 1));
                        // End page
                        case "to" -> options.toPage = Integer.parseInt(args.get(i + 1));
                        // Sort
                        case "sort" -> options.sort = Integer.parseInt(args.get(i + 1));
                        // Downloads folder
                        case "dir" -> options.downloadFolder = args.get(i + 1);
                        // Amount of threads
                        case "threads" -> options.threads = Integer.parseInt(args.get(i + 1));
                        // Per project folders
                        case "multidir" -> options.perProjectDirs = Boolean.parseBoolean(args.get(i + 1));
                    }
                }
            }

            return options;
        }

    }

}