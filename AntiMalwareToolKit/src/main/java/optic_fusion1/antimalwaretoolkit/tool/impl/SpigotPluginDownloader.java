package optic_fusion1.antimalwaretoolkit.tool.impl;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.attribute.FileTime;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.LongAdder;
import static optic_fusion1.antimalwaretoolkit.Main.LOGGER;
import optic_fusion1.antimalwaretoolkit.tool.Tool;
import org.apache.commons.io.IOUtils;

// TODO: Make a tool like this, but for github. Example api link https://api.github.com/repos/EssentialsX/Essentials/releases?per-page=100
public class SpigotPluginDownloader extends Tool {

  private static final int threadCount = Integer.getInteger("downloader.threadcount", 4);
  private final LongAdder downloaded = new LongAdder();
  private final LongAdder downloadError = new LongAdder();
  private final LongAdder noNewUpdate = new LongAdder();
  private final LongAdder oldUpdateMoved = new LongAdder();
  private final LongAdder moveError = new LongAdder();
  private final LongAdder moveNotExist = new LongAdder();
  private final LongAdder skippedExternal = new LongAdder();
  private final LongAdder skippedSkript = new LongAdder();
  private final LongAdder skippedFileSizeZero = new LongAdder();
  private final LongAdder skippedNoSize = new LongAdder();
  private final LongAdder otherError = new LongAdder();

  @Override
  public void run(List<String> args) {
    downloaded.reset();
    downloadError.reset();
    noNewUpdate.reset();
    oldUpdateMoved.reset();
    moveError.reset();
    moveNotExist.reset();
    skippedExternal.reset();
    skippedSkript.reset();
    skippedFileSizeZero.reset();
    skippedNoSize.reset();
    otherError.reset();
    LOGGER.info("Downloading with " + threadCount + " threads");
    int startingPage = 0;
    int pageCount = 10;
    String url = "https://api.spiget.org/v2/resources/free?size=10&page=";
    if (args.size() >= 1) {
      if (args.get(0).equalsIgnoreCase("latest")) {
        url = "https://api.spiget.org/v2/resources/free?size=10&sort=-updateDate&fields=file,name,version,updateDate,releaseDate&page=";
        if (args.size() >= 2) {
          startingPage = Integer.parseInt(args.get(1));
          if (args.size() >= 3) {
            pageCount = Integer.parseInt(args.get(2));
          }
        }
      } else {
        startingPage = Integer.parseInt(args.get(0));
        if (args.size() >= 2) {
          pageCount = Integer.parseInt(args.get(1));
        }
      }
    }
    File dlFolder = new File("data/plugins");
    dlFolder.mkdirs();
    File oldFolder = new File("data/old");
    oldFolder.mkdirs();
    Multimap<String, String> files = HashMultimap.create(1000, 1);
    for (String fileName : dlFolder.list()) {
      String[] split = fileName.split("_lastUpdate");
      if (split.length != 2) {
        LOGGER.info("Unknown file " + fileName + ", ignoring...");
        continue;
      }
      files.put(split[0], split[1]);
    }
    LOGGER.info("Found " + files.size() + " existing files, " + files.keySet().size() + " distinct plugins");
    LOGGER.info("Starting downloader");
    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
    int maxPage = startingPage + pageCount;
    for (int page = startingPage; page < maxPage; page++) {
      LOGGER.info("Scheduling spiget page " + page);
      String urlFinal = url;
      int pageFinal = page;
      executor.submit(() -> {
        try {
          LOGGER.info("Downloading spiget page " + pageFinal);
          downloadPage(dlFolder, oldFolder, urlFinal, pageFinal, files);
        } catch (Throwable t) {
          otherError.increment();
          t.printStackTrace();
        }
      });
    }
    executor.shutdown();
    while (!executor.isTerminated()) {
      try {
        if (executor.awaitTermination(1, TimeUnit.MINUTES)) {
          if (executor.isTerminated()) {
            break;
          }
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    LOGGER.info("Done, downloaded spiget pages " + startingPage + " to " + (maxPage - 1));
    LOGGER.info("Downloaded: " + downloaded + ", noNewUpdate: " + noNewUpdate + ", oldUpdateMoved: " + oldUpdateMoved + ", downloadError: " + downloadError);
    LOGGER.info("moveError: " + moveError + ", moveNotExist: " + moveNotExist + ", skippedExternal: " + skippedExternal + ", skippedSkript: " + skippedSkript
            + ", skippedFileSizeZero: " + skippedFileSizeZero + ", skippedNoSize: " + skippedNoSize);
    LOGGER.info("other errors: " + otherError);
  }

  private boolean downloadPage(File dlFolder, File oldFolder, String baseUrl, int currentPage, Multimap<String, String> existing) {
    String urlString = baseUrl + currentPage;
    LOGGER.info("Downloading the page: " + urlString);
    String jsonString = "";
    try {
      jsonString = downloadToString(urlString);
    } catch (IOException ex) {
      LOGGER.exception(ex);
    }
    if (jsonString.isEmpty() || jsonString.equalsIgnoreCase("[]")) {
      LOGGER.info("Max page reached");
      return false;
    }
    for (JsonElement element : JsonParser.parseString(jsonString).getAsJsonArray()) {
      JsonObject jsonObject = element.getAsJsonObject();
      if (jsonObject == null) {
        LOGGER.info("Found a null plugin");
        continue;
      }
      JsonObject pluginInformation = jsonObject.getAsJsonObject();
      JsonObject pluginFileInformation = pluginInformation.getAsJsonObject("file");

      String fileType = pluginFileInformation == null ? ".jar" : pluginFileInformation.get("type").getAsString();

      String id = pluginInformation.get("id").getAsString().replaceAll("\\.", "");
      String name = pluginInformation.get("name").getAsString();

      if (fileType.equals("external")) {
        LOGGER.info("Skipping external file: id: " + id + " name: " + name);
        skippedExternal.increment();
        continue;
      } else if (fileType.equals(".skript") || fileType.equals(".sk")) {
        LOGGER.info("Skipping skript id: " + id + " name: " + name);
        skippedSkript.increment();
        continue;
      }
      double fileSize = 0;
      try {
        fileSize = pluginFileInformation.get("size").getAsDouble();
      } catch (NullPointerException e) {
        e.printStackTrace();
        skippedNoSize.increment();
        continue;
      }
      if (fileSize == 0) {
        skippedFileSizeZero.increment();
        continue;
      }
      long updateDate = pluginInformation.get("updateDate").getAsLong();
      long releaseDate = pluginInformation.get("releaseDate").getAsLong();
      String lastUpdateStr = "_lastUpdate(" + updateDate + ")";
      LOGGER.info("Downloading " + name + "_id(" + id + ")" + lastUpdateStr);
      String fileNamePart1 = name.replaceAll("[^a-zA-Z0-9]", "") + "_id(" + id + ")";
      String fileNamePart2 = lastUpdateStr + fileType;
      Collection<String> exist = existing.get(fileNamePart1);
      if (!exist.isEmpty()) {
        for (String checkFileNamePartIncomplete : exist) {
          String checkFileNamePart2 = "_lastUpdate" + checkFileNamePartIncomplete;
          String checkFileName = fileNamePart1 + checkFileNamePart2;

          if (!fileNamePart2.equals(checkFileNamePart2)) {
            try {
              File fileToMove = new File(dlFolder, checkFileName);
              if (!fileToMove.exists()) {
                LOGGER.info(" " + fileToMove + " does not exist?! ##########################################");
                moveNotExist.increment();
                continue;
              }
              Files.move(fileToMove.toPath(), new File(oldFolder, checkFileName).toPath(),
                      StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
              oldUpdateMoved.increment();
            } catch (Exception e) {
              moveError.increment();
              e.printStackTrace();
            }
          }
        }
      }

      String fileName = fileNamePart1 + fileNamePart2;
      File output = new File(dlFolder, fileName);
      if (!output.exists()) {
        if (download(id, output, releaseDate, updateDate)) {
          downloaded.increment();
          LOGGER.info("  Downloaded " + name + " id: " + id + ", File Type: " + fileType);
          LOGGER.info("    Output: " + fileName);
        } else {
          downloadError.increment();
          LOGGER.info("  Error during download of id: " + id + " name: " + name);
        }
      } else {
        noNewUpdate.increment();
        LOGGER.info("  No new update for " + fileName);
      }
    }
    return true;
  }

  private boolean download(String resourceID, File output, long releaseDate, long updateDate) {
    try {
      URL url = new URL("https://api.spiget.org/v2/resources/" + resourceID + "/download");
      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
      conn.setInstanceFollowRedirects(true);
      conn.setRequestProperty("User-Agent", "Optic_Fusion1 AntimalwareToolkit");
      conn.setRequestMethod("GET");
      int responseCode = conn.getResponseCode();
      if (responseCode == 307) {
        String location = conn.getHeaderField("Location");
        if (location == null) {
          LOGGER.info("  Redirect without location for url: " + url.getPath());
        } else {
          LOGGER.info("  Redirected to: " + location);
          url = new URL(location);
          conn = (HttpURLConnection) url.openConnection();
          conn.setInstanceFollowRedirects(true);
          conn.setRequestProperty("User-Agent", "Optic_Fusion1 AntimalwareToolkit");
          conn.setRequestMethod("GET");
        }
      } else if (responseCode != 200) {
        LOGGER.info("  Response code was " + responseCode + " for resource " + resourceID);
      }

      InputStream inputStream = conn.getInputStream();
      OutputStream fileOutputStream = new BufferedOutputStream(new FileOutputStream(output));
      IOUtils.copy(inputStream, fileOutputStream);

      try {
        fileOutputStream.flush();
      } catch (IOException e) {
        System.err.println("  Flush error for " + resourceID);
        e.printStackTrace();
      }
      try {
        IOUtils.close(fileOutputStream);
      } catch (Exception ex) {
        System.err.println("  Close error 1 for " + resourceID);
        ex.printStackTrace();
      }

      Path outputPath = output.toPath();
      Files.setAttribute(outputPath, "creationTime", FileTime.from(releaseDate, TimeUnit.SECONDS));
      Files.setLastModifiedTime(outputPath, FileTime.from(updateDate, TimeUnit.SECONDS));
      try {
        IOUtils.close(inputStream);
      } catch (Exception ex) {
        System.err.println("  Close error 2 for " + resourceID);
        ex.printStackTrace();
      }
      try {
        IOUtils.close(conn);
      } catch (Exception ex) {
        System.err.println("  Close error 3 for " + resourceID);
        ex.printStackTrace();
      }
    } catch (Exception ex) {
      System.err.println("  Could not download resource " + resourceID);
      ex.printStackTrace();
      output.delete();
      return false;
    }
    return true;
  }

  @Override
  public String getDescription() {
    return "Downloads every spigot plugin";
  }

  private String downloadToString(String urlString) throws IOException {
    URL url = new URL(urlString);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.addRequestProperty("User-Agent", "Optic_Fusion1 AntimalwareToolkit");
    return IOUtils.toString(conn.getInputStream(), StandardCharsets.UTF_8);
  }

}
