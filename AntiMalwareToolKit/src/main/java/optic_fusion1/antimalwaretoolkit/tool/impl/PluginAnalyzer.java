/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package optic_fusion1.antimalwaretoolkit.tool.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystemLoopException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;
import static optic_fusion1.antimalwaretoolkit.Main.LOGGER;
import optic_fusion1.antimalwaretoolkit.tool.Tool;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public class PluginAnalyzer extends Tool {

  boolean exportClassFiles;
  Map<Pattern, Integer> stringFilters;
  Map<Pattern, Integer> methodFilters;
  int foundPlugins = 0;

  @Override
  public void run(List<String> args) {
    foundPlugins = 0;
    File toAnalyze = new File(args.get(0));
    if (!toAnalyze.exists()) {
      LOGGER.info("The File " + args.get(0) + " doesn't exist!");
      return;
    }
    exportClassFiles = args.contains("-e");
    if (exportClassFiles) {
      new File("exportedClassFiles").mkdirs();
    }
    stringFilters = args.stream().filter((str) -> str.startsWith("-s")).map((str) -> str.substring(2))
            .collect(Collectors.toMap((str) -> Pattern.compile(str), (str) -> 0));
    methodFilters = args.stream().filter((method) -> method.startsWith("-m"))
            .map((method) -> method.substring(2))
            .collect(Collectors.toMap((method) -> Pattern.compile(method), (method) -> 0));

    if (toAnalyze.isDirectory()) {
      analyzeDirectory(toAnalyze.toPath());
    } else {
      analyzeFile(toAnalyze.toPath());
    }
    LOGGER.info("--- OVERVIEW ---");
    LOGGER.info(foundPlugins + " Plugins matched the Filters");
    LOGGER.info("--- StringFilters ---");
    for (Pattern p : stringFilters.keySet()) {
      LOGGER.info(p.toString() + ": " + stringFilters.get(p));
    }
    LOGGER.info("--- MethodFilters ---");
    for (Pattern p : methodFilters.keySet()) {
      LOGGER.info(p.toString() + ": " + methodFilters.get(p));
    }
  }

  private void analyzeDirectory(Path toAnalyze) {
    try {
      Files.list(toAnalyze).forEach(this::analyzeFile);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private void analyzeFile(Path file) {
    if (file.getFileName().toString().endsWith(".zip")) {
      analyzeZip(file);
      return;
    } else if (file.getFileName().toString().endsWith(".jar")) {
      try (FileSystem fs = FileSystems.newFileSystem(file)) {
        boolean matched = StreamSupport.stream(fs.getRootDirectories().spliterator(), false).anyMatch((dir) -> {
          try {
            return scanInnerDirectory(dir, file);
          } catch (Exception e) {
            e.printStackTrace();
          }
          return false;
        });
        if (matched) {
          foundPlugins++;
        }
      } catch (FileSystemLoopException loop) {
        loop.printStackTrace();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

  private boolean scanInnerDirectory(Path dir, Path outerFile) {
    try {
      return Files.list(dir).anyMatch((path) -> {
        if (!Files.isSymbolicLink(path)) {
          if (Files.isDirectory(path)) {
            return scanInnerDirectory(path, outerFile);
          } else {
            return analyzeInnerFile(dir, outerFile);
          }
        }
        return false;
      });
    } catch (IOException e) {
      e.printStackTrace();
    }
    return false;
  }

  private boolean analyzeInnerFile(Path path, Path outerFile) {
    if (path != null && path.getFileName() != null) {
      if (path.getFileName().toString().endsWith(".class")) {
        try {
          ClassReader cr = new ClassReader(Files.newInputStream(path));
          ClassNode classNode = new ClassNode();
          cr.accept(classNode, 0);
          boolean strings = searchForStrings(path, classNode);
          boolean methods = searchForMethods(path, classNode);
          if (strings && methods) {
            LOGGER.info("[FOUND] Class " + classNode.name + " in File "
                    + outerFile.toAbsolutePath().toString() + " matches!");
            if (exportClassFiles) {
              new File("exportedClassFiles/" + outerFile.getFileName().toString()).mkdirs();
              Files.copy(path, new FileOutputStream("exportedClassFiles/"
                      + outerFile.getFileName().toString() + "/" + path.getFileName().toString()));
            }
            return true;
          }
        } catch (Exception e) {
          LOGGER.info("ERROR " + e.getMessage() + " " + path.toString());
        }
      }
    }
    return false;
  }

  private boolean searchForStrings(Path path, ClassNode classNode) {
    if (stringFilters.isEmpty()) {
      return true;
    }
    List<String> strings = new ArrayList<>();
    for (MethodNode methodNode : classNode.methods) {
      for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
        if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
          String str = (String) ((LdcInsnNode) insnNode).cst;
          strings.add(str);
        }
      }
    }
    Map<Pattern, Integer> stringFiltersCopy = new HashMap<Pattern, Integer>(stringFilters);
    long count = strings.stream().flatMap((str) -> stringFilters.keySet().stream().filter((pat) -> {
      if (pat.matcher(str).find()) {
        stringFiltersCopy.put(pat, stringFiltersCopy.get(pat) + 1);
        return true;
      }
      return false;
    })).distinct().count();
    stringFilters = stringFiltersCopy;
    return stringFilters.size() == count;
  }

  private boolean searchForMethods(Path path, ClassNode classNode) {
    if (methodFilters.isEmpty()) {
      return true;
    }
    List<String> methods = new ArrayList<>();
    for (MethodNode methodNode : classNode.methods) {
      for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
        if (insnNode instanceof MethodInsnNode) {
          String str = ((MethodInsnNode) insnNode).owner + "#" + ((MethodInsnNode) insnNode).name
                  + ((MethodInsnNode) insnNode).desc;
          if (str.length() > 1000) {
            LOGGER.info(
                    "Class " + path.toAbsolutePath().toString() + " contains ultra long Method: " + str);
          }
          methods.add(str);
          if (methods.size() == 5000) {
            LOGGER.info("Class " + path.toAbsolutePath().toString() + " has over 5000 methods!");
          }
        } else if (insnNode instanceof InvokeDynamicInsnNode) {
          String str = ((InvokeDynamicInsnNode) insnNode).name + ((InvokeDynamicInsnNode) insnNode).desc;
          methods.add(str);
        }
      }
    }
    Map<Pattern, Integer> methodFiltersCopy = new HashMap<Pattern, Integer>(methodFilters);
    long count = methods.stream().flatMap((str) -> methodFilters.keySet().stream().filter((pat) -> {
      if (pat.matcher(str).find()) {
        methodFiltersCopy.put(pat, methodFiltersCopy.get(pat) + 1);
        return true;
      }
      return false;
    })).distinct().count();
    methodFilters = methodFiltersCopy;
    return methodFilters.size() == count;
  }

  private void analyzeZip(Path file) {
    try (FileSystem fs = FileSystems.newFileSystem(file)) {
      fs.getRootDirectories().forEach(this::analyzeDirectory);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public String getDescription() {
    return "Allows analyzing Single/Multiple Plugins by searching for certain Structures\n" + "Options: \n"
            + "  ExportClassFiles: -e\n" + "  FilterForString: -s{STRING}\n" + "  FilterForMethod: -m{METHOD}";
  }

}
